// SPDX-License-Identifier: EUPL-1.2
// Linear Type Checking Bootstrap Demo
//
// Proves: Ephapax affine compiler can compile linear type checking logic
// Strategy: Inline everything, avoid function references

fn main() -> i32 {
    // ========================================================================
    // Test 1: Affine variable can be dropped
    // ========================================================================
    // Simulates: let x = 42; (not used)
    // Expected: OK (0)

    let is_linear_1 = 0;  // affine
    let was_used_1 = 0;   // not consumed
    let not_used_1 = 1 - was_used_1;
    let test1 = is_linear_1 * not_used_1;  // 0 * 1 = 0 (OK)

    // ========================================================================
    // Test 2: Linear variable must be consumed
    // ========================================================================
    // Simulates: let! x = 42; (not used)
    // Expected: ERROR (1)

    let is_linear_2 = 1;  // linear
    let was_used_2 = 0;   // not consumed
    let not_used_2 = 1 - was_used_2;
    let test2 = is_linear_2 * not_used_2;  // 1 * 1 = 1 (ERROR)

    // ========================================================================
    // Test 3: Linear variable properly consumed
    // ========================================================================
    // Simulates: let! x = 42; drop(x);
    // Expected: OK (0)

    let is_linear_3 = 1;  // linear
    let was_used_3 = 1;   // consumed
    let not_used_3 = 1 - was_used_3;
    let test3 = is_linear_3 * not_used_3;  // 1 * 0 = 0 (OK)

    // ========================================================================
    // Test 4: Cannot reuse consumed variable
    // ========================================================================
    // Simulates: let! x = 42; let y = x; let z = x; (ERROR)
    // Expected: ERROR (1)

    let is_consumed_4 = 1;  // already used
    let test4 = is_consumed_4;  // 1 (ERROR)

    // ========================================================================
    // Validation: Sum should be 0+1+0+1 = 2
    // ========================================================================

    let partial1 = test1 + test2;  // 0 + 1 = 1
    let partial2 = test3 + test4;  // 0 + 1 = 1
    let sum = partial1 + partial2;  // 1 + 1 = 2

    let expected = 2;
    let diff = sum - expected;  // Should be 0
    let result = diff * diff;   // 0 if correct, >0 if wrong

    // Return 0 = Linear type checking works correctly!
    // Return >0 = Something is wrong
    result
}
